{
    "summary": "This code contains functions for bounding box manipulation and GIoU, including coordinate system conversion utilities, IOU calculation, modified torchvision box_iou function, and two functions for computing mask coordinates.",
    "details": [
        {
            "comment": "This code is from the \"act-plus-plus/detr/util/box_ops.py\" file and contains functions for bounding box manipulation and GIoU (Generalized Intersection over Union). The code includes utilities to convert between (cxcywh) and (xyxy) coordinate systems, and calculate the IOU (Intersection Over Union) and Generalized Box IOU between two sets of boxes. It also includes a modified version of torchvision's box_iou function that returns the union as well.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/detr/util/box_ops.py\":0-40",
            "content": "# Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved\n\"\"\"\nUtilities for bounding box manipulation and GIoU.\n\"\"\"\nimport torch\nfrom torchvision.ops.boxes import box_area\ndef box_cxcywh_to_xyxy(x):\n    x_c, y_c, w, h = x.unbind(-1)\n    b = [(x_c - 0.5 * w), (y_c - 0.5 * h),\n         (x_c + 0.5 * w), (y_c + 0.5 * h)]\n    return torch.stack(b, dim=-1)\ndef box_xyxy_to_cxcywh(x):\n    x0, y0, x1, y1 = x.unbind(-1)\n    b = [(x0 + x1) / 2, (y0 + y1) / 2,\n         (x1 - x0), (y1 - y0)]\n    return torch.stack(b, dim=-1)\n# modified from torchvision to also return the union\ndef box_iou(boxes1, boxes2):\n    area1 = box_area(boxes1)\n    area2 = box_area(boxes2)\n    lt = torch.max(boxes1[:, None, :2], boxes2[:, :2])  # [N,M,2]\n    rb = torch.min(boxes1[:, None, 2:], boxes2[:, 2:])  # [N,M,2]\n    wh = (rb - lt).clamp(min=0)  # [N,M,2]\n    inter = wh[:, :, 0] * wh[:, :, 1]  # [N,M]\n    union = area1[:, None] + area2 - inter\n    iou = inter / union\n    return iou, union\ndef generalized_box_iou(boxes1, boxes2):\n    \"\"\""
        },
        {
            "comment": "The code snippet contains two functions: \"generalized_iou\" and \"masks_to_boxes\". The first function calculates a pairwise matrix of Intersection over Union (IoU) between two sets of bounding boxes, taking into account degenerate cases. It asserts that the boxes are in the correct format and computes the IoU and union area between boxes. The second function takes a set of masks and returns the corresponding bounding boxes in xyxy format. It checks if the mask tensor is empty and then calculates the y-coordinates for the bounding boxes.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/detr/util/box_ops.py\":41-75",
            "content": "    Generalized IoU from https://giou.stanford.edu/\n    The boxes should be in [x0, y0, x1, y1] format\n    Returns a [N, M] pairwise matrix, where N = len(boxes1)\n    and M = len(boxes2)\n    \"\"\"\n    # degenerate boxes gives inf / nan results\n    # so do an early check\n    assert (boxes1[:, 2:] >= boxes1[:, :2]).all()\n    assert (boxes2[:, 2:] >= boxes2[:, :2]).all()\n    iou, union = box_iou(boxes1, boxes2)\n    lt = torch.min(boxes1[:, None, :2], boxes2[:, :2])\n    rb = torch.max(boxes1[:, None, 2:], boxes2[:, 2:])\n    wh = (rb - lt).clamp(min=0)  # [N,M,2]\n    area = wh[:, :, 0] * wh[:, :, 1]\n    return iou - (area - union) / area\ndef masks_to_boxes(masks):\n    \"\"\"Compute the bounding boxes around the provided masks\n    The masks should be in format [N, H, W] where N is the number of masks, (H, W) are the spatial dimensions.\n    Returns a [N, 4] tensors, with the boxes in xyxy format\n    \"\"\"\n    if masks.numel() == 0:\n        return torch.zeros((0, 4), device=masks.device)\n    h, w = masks.shape[-2:]\n    y = torch.arange(0, h, dtype=torch.float)"
        },
        {
            "comment": "Computes the minimum and maximum x,y coordinates within masks using meshgrid and masked fill operations, then stacks them into a tensor.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/detr/util/box_ops.py\":76-87",
            "content": "    x = torch.arange(0, w, dtype=torch.float)\n    y, x = torch.meshgrid(y, x)\n    x_mask = (masks * x.unsqueeze(0))\n    x_max = x_mask.flatten(1).max(-1)[0]\n    x_min = x_mask.masked_fill(~(masks.bool()), 1e8).flatten(1).min(-1)[0]\n    y_mask = (masks * y.unsqueeze(0))\n    y_max = y_mask.flatten(1).max(-1)[0]\n    y_min = y_mask.masked_fill(~(masks.bool()), 1e8).flatten(1).min(-1)[0]\n    return torch.stack([x_min, y_min, x_max, y_max], 1)"
        }
    ]
}