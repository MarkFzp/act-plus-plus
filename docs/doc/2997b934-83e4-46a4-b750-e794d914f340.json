{
    "summary": "The code introduces a `BasePolicy` class for robotic arm policy, incorporating trajectory generation, updating poses and gripper commands, and executing pre-generated trajectories. It initializes an environment and runs two episodes of actions using PickAndTransferPolicy to test cube transfer simulation scripts.",
    "details": [
        {
            "comment": "The code defines a `BasePolicy` class for a robotic arm policy with methods to generate and interpolate trajectories. It imports necessary libraries, handles injecting noise, and includes utility functions.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":0-32",
            "content": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom pyquaternion import Quaternion\nfrom constants import SIM_TASK_CONFIGS\nfrom ee_sim_env import make_ee_sim_env\nimport IPython\ne = IPython.embed\nclass BasePolicy:\n    def __init__(self, inject_noise=False):\n        self.inject_noise = inject_noise\n        self.step_count = 0\n        self.left_trajectory = None\n        self.right_trajectory = None\n    def generate_trajectory(self, ts_first):\n        raise NotImplementedError\n    @staticmethod\n    def interpolate(curr_waypoint, next_waypoint, t):\n        t_frac = (t - curr_waypoint[\"t\"]) / (next_waypoint[\"t\"] - curr_waypoint[\"t\"])\n        curr_xyz = curr_waypoint['xyz']\n        curr_quat = curr_waypoint['quat']\n        curr_grip = curr_waypoint['gripper']\n        next_xyz = next_waypoint['xyz']\n        next_quat = next_waypoint['quat']\n        next_grip = next_waypoint['gripper']\n        xyz = curr_xyz + (next_xyz - curr_xyz) * t_frac\n        quat = curr_quat + (next_quat - curr_quat) * t_frac\n        gripper = curr_grip + (next_grip - curr_grip) * t_frac"
        },
        {
            "comment": "This code is responsible for executing a pre-generated trajectory by interpolating between waypoints, obtaining the current pose and gripper command for both left and right sides. It also allows injecting noise if enabled. The function is called at each timestep to update the pose and gripper commands.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":33-55",
            "content": "        return xyz, quat, gripper\n    def __call__(self, ts):\n        # generate trajectory at first timestep, then open-loop execution\n        if self.step_count == 0:\n            self.generate_trajectory(ts)\n        # obtain left and right waypoints\n        if self.left_trajectory[0]['t'] == self.step_count:\n            self.curr_left_waypoint = self.left_trajectory.pop(0)\n        next_left_waypoint = self.left_trajectory[0]\n        if self.right_trajectory[0]['t'] == self.step_count:\n            self.curr_right_waypoint = self.right_trajectory.pop(0)\n        next_right_waypoint = self.right_trajectory[0]\n        # interpolate between waypoints to obtain current pose and gripper command\n        left_xyz, left_quat, left_gripper = self.interpolate(self.curr_left_waypoint, next_left_waypoint, self.step_count)\n        right_xyz, right_quat, right_gripper = self.interpolate(self.curr_right_waypoint, next_right_waypoint, self.step_count)\n        # Inject noise\n        if self.inject_noise:\n            scale = 0.01"
        },
        {
            "comment": "The code snippet is part of a PickAndTransferPolicy class. It generates a trajectory for picking up an object and transferring it from one robot arm to another. The code adds random uniform noise to the action coordinates, concatenates the actions with quaternions and gripper states, increments the step count, and returns the combined action for both arms. The method also initializes variables based on the first time step observation, including the initial mocap poses of both robot arms and box information (XYZ and quaternion).",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":56-80",
            "content": "            left_xyz = left_xyz + np.random.uniform(-scale, scale, left_xyz.shape)\n            right_xyz = right_xyz + np.random.uniform(-scale, scale, right_xyz.shape)\n        action_left = np.concatenate([left_xyz, left_quat, [left_gripper]])\n        action_right = np.concatenate([right_xyz, right_quat, [right_gripper]])\n        self.step_count += 1\n        return np.concatenate([action_left, action_right])\nclass PickAndTransferPolicy(BasePolicy):\n    def generate_trajectory(self, ts_first):\n        init_mocap_pose_right = ts_first.observation['mocap_pose_right']\n        init_mocap_pose_left = ts_first.observation['mocap_pose_left']\n        box_info = np.array(ts_first.observation['env_state'])\n        box_xyz = box_info[:3]\n        box_quat = box_info[3:]\n        # print(f\"Generate trajectory for {box_xyz=}\")\n        gripper_pick_quat = Quaternion(init_mocap_pose_right[3:])\n        gripper_pick_quat = gripper_pick_quat * Quaternion(axis=[0.0, 1.0, 0.0], degrees=-60)\n        meet_left_quat = Quaternion(axis=[1.0, 0.0, 0.0], degrees=90)"
        },
        {
            "comment": "Code defines trajectory for left and right robot arms. Left arm starts by sleeping, then approaches and moves to meet position, closes gripper, moves left, and stays at final position. Right arm also sleeps, follows similar steps as left arm. All movements are time-based.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":82-94",
            "content": "        meet_xyz = np.array([0, 0.5, 0.25])\n        self.left_trajectory = [\n            {\"t\": 0, \"xyz\": init_mocap_pose_left[:3], \"quat\": init_mocap_pose_left[3:], \"gripper\": 0}, # sleep\n            {\"t\": 100, \"xyz\": meet_xyz + np.array([-0.1, 0, -0.02]), \"quat\": meet_left_quat.elements, \"gripper\": 1}, # approach meet position\n            {\"t\": 260, \"xyz\": meet_xyz + np.array([0.02, 0, -0.02]), \"quat\": meet_left_quat.elements, \"gripper\": 1}, # move to meet position\n            {\"t\": 310, \"xyz\": meet_xyz + np.array([0.02, 0, -0.02]), \"quat\": meet_left_quat.elements, \"gripper\": 0}, # close gripper\n            {\"t\": 360, \"xyz\": meet_xyz + np.array([-0.1, 0, -0.02]), \"quat\": np.array([1, 0, 0, 0]), \"gripper\": 0}, # move left\n            {\"t\": 400, \"xyz\": meet_xyz + np.array([-0.1, 0, -0.02]), \"quat\": np.array([1, 0, 0, 0]), \"gripper\": 0}, # stay\n        ]\n        self.right_trajectory = [\n            {\"t\": 0, \"xyz\": init_mocap_pose_right[:3], \"quat\": init_mocap_pose_right[3:], \"gripper\": 0}, # sleep"
        },
        {
            "comment": "This code represents a sequence of actions for a robot gripper. It begins by approaching and gripping the cube, then moving downwards, closing the gripper at a certain position, moving to a meet position, opening the gripper, and finally moving right and staying in that position. The actions are time-based with specific positions and gripper states.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":95-102",
            "content": "            {\"t\": 90, \"xyz\": box_xyz + np.array([0, 0, 0.08]), \"quat\": gripper_pick_quat.elements, \"gripper\": 1}, # approach the cube\n            {\"t\": 130, \"xyz\": box_xyz + np.array([0, 0, -0.015]), \"quat\": gripper_pick_quat.elements, \"gripper\": 1}, # go down\n            {\"t\": 170, \"xyz\": box_xyz + np.array([0, 0, -0.015]), \"quat\": gripper_pick_quat.elements, \"gripper\": 0}, # close gripper\n            {\"t\": 200, \"xyz\": meet_xyz + np.array([0.05, 0, 0]), \"quat\": gripper_pick_quat.elements, \"gripper\": 0}, # approach meet position\n            {\"t\": 220, \"xyz\": meet_xyz, \"quat\": gripper_pick_quat.elements, \"gripper\": 0}, # move to meet position\n            {\"t\": 310, \"xyz\": meet_xyz, \"quat\": gripper_pick_quat.elements, \"gripper\": 1}, # open gripper\n            {\"t\": 360, \"xyz\": meet_xyz + np.array([0.1, 0, 0]), \"quat\": gripper_pick_quat.elements, \"gripper\": 1}, # move to right\n            {\"t\": 400, \"xyz\": meet_xyz + np.array([0.1, 0, 0]), \"quat\": gripper_pick_quat.elements, \"gripper\": 1}, # stay"
        },
        {
            "comment": "This code initializes variables for the InsertionPolicy class's generate_trajectory method. It extracts information from the observation and calculates gripper quaternions for both hands, defining their starting positions and orientation. The meet_xyz variable represents a specific target position, while lift_right is an arbitrary value. The left_trajectory list is initialized with the first point as the initial mocap pose of the left hand in sleep mode.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":103-130",
            "content": "        ]\nclass InsertionPolicy(BasePolicy):\n    def generate_trajectory(self, ts_first):\n        init_mocap_pose_right = ts_first.observation['mocap_pose_right']\n        init_mocap_pose_left = ts_first.observation['mocap_pose_left']\n        peg_info = np.array(ts_first.observation['env_state'])[:7]\n        peg_xyz = peg_info[:3]\n        peg_quat = peg_info[3:]\n        socket_info = np.array(ts_first.observation['env_state'])[7:]\n        socket_xyz = socket_info[:3]\n        socket_quat = socket_info[3:]\n        gripper_pick_quat_right = Quaternion(init_mocap_pose_right[3:])\n        gripper_pick_quat_right = gripper_pick_quat_right * Quaternion(axis=[0.0, 1.0, 0.0], degrees=-60)\n        gripper_pick_quat_left = Quaternion(init_mocap_pose_right[3:])\n        gripper_pick_quat_left = gripper_pick_quat_left * Quaternion(axis=[0.0, 1.0, 0.0], degrees=60)\n        meet_xyz = np.array([0, 0.5, 0.15])\n        lift_right = 0.00715\n        self.left_trajectory = [\n            {\"t\": 0, \"xyz\": init_mocap_pose_left[:3], \"quat\": init_mocap_pose_left[3:], \"gripper\": 0}, # sleep"
        },
        {
            "comment": "This code defines a list of trajectory points for left and right arms, specifying their xyz coordinates, orientation quaternion, and gripper state at each time step. It follows a sequence of actions such as approaching the cube, going down, closing the gripper, and reaching insertion positions.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":131-141",
            "content": "            {\"t\": 120, \"xyz\": socket_xyz + np.array([0, 0, 0.08]), \"quat\": gripper_pick_quat_left.elements, \"gripper\": 1}, # approach the cube\n            {\"t\": 170, \"xyz\": socket_xyz + np.array([0, 0, -0.03]), \"quat\": gripper_pick_quat_left.elements, \"gripper\": 1}, # go down\n            {\"t\": 220, \"xyz\": socket_xyz + np.array([0, 0, -0.03]), \"quat\": gripper_pick_quat_left.elements, \"gripper\": 0}, # close gripper\n            {\"t\": 285, \"xyz\": meet_xyz + np.array([-0.1, 0, 0]), \"quat\": gripper_pick_quat_left.elements, \"gripper\": 0}, # approach meet position\n            {\"t\": 340, \"xyz\": meet_xyz + np.array([-0.05, 0, 0]), \"quat\": gripper_pick_quat_left.elements,\"gripper\": 0},  # insertion\n            {\"t\": 400, \"xyz\": meet_xyz + np.array([-0.05, 0, 0]), \"quat\": gripper_pick_quat_left.elements, \"gripper\": 0},  # insertion\n        ]\n        self.right_trajectory = [\n            {\"t\": 0, \"xyz\": init_mocap_pose_right[:3], \"quat\": init_mocap_pose_right[3:], \"gripper\": 0}, # sleep\n            {\"t\": 12"
        },
        {
            "comment": "This code defines a policy for picking up and transferring an object, with specific timings and positions. The policy is applied within the `test_policy` function, which also sets up the environment and allows for onscreen rendering and noise injection.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":141-157",
            "content": "0, \"xyz\": peg_xyz + np.array([0, 0, 0.08]), \"quat\": gripper_pick_quat_right.elements, \"gripper\": 1}, # approach the cube\n            {\"t\": 170, \"xyz\": peg_xyz + np.array([0, 0, -0.03]), \"quat\": gripper_pick_quat_right.elements, \"gripper\": 1}, # go down\n            {\"t\": 220, \"xyz\": peg_xyz + np.array([0, 0, -0.03]), \"quat\": gripper_pick_quat_right.elements, \"gripper\": 0}, # close gripper\n            {\"t\": 285, \"xyz\": meet_xyz + np.array([0.1, 0, lift_right]), \"quat\": gripper_pick_quat_right.elements, \"gripper\": 0}, # approach meet position\n            {\"t\": 340, \"xyz\": meet_xyz + np.array([0.05, 0, lift_right]), \"quat\": gripper_pick_quat_right.elements, \"gripper\": 0},  # insertion\n            {\"t\": 400, \"xyz\": meet_xyz + np.array([0.05, 0, lift_right]), \"quat\": gripper_pick_quat_right.elements, \"gripper\": 0},  # insertion\n        ]\ndef test_policy(task_name):\n    # example rolling out pick_and_transfer policy\n    onscreen_render = True\n    inject_noise = False\n    # setup the environment\n    episode_len = SIM_TASK_CONFIGS[task_name]['episode_len']"
        },
        {
            "comment": "The code initializes an environment (env) depending on the task_name, and then executes two episodes of actions. For each episode, it resets the environment, performs actions based on a PickAndTransferPolicy, and updates the state. If onscreen_render is True, it renders the state using matplotlib. It calculates the episode return and prints whether the episode was successful or not based on the return value. The code is called as a main function.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":158-190",
            "content": "    if 'sim_transfer_cube' in task_name:\n        env = make_ee_sim_env('sim_transfer_cube')\n    elif 'sim_insertion' in task_name:\n        env = make_ee_sim_env('sim_insertion')\n    else:\n        raise NotImplementedError\n    for episode_idx in range(2):\n        ts = env.reset()\n        episode = [ts]\n        if onscreen_render:\n            ax = plt.subplot()\n            plt_img = ax.imshow(ts.observation['images']['angle'])\n            plt.ion()\n        policy = PickAndTransferPolicy(inject_noise)\n        for step in range(episode_len):\n            action = policy(ts)\n            ts = env.step(action)\n            episode.append(ts)\n            if onscreen_render:\n                plt_img.set_data(ts.observation['images']['angle'])\n                plt.pause(0.02)\n        plt.close()\n        episode_return = np.sum([ts.reward for ts in episode[1:]])\n        if episode_return > 0:\n            print(f\"{episode_idx=} Successful, {episode_return=}\")\n        else:\n            print(f\"{episode_idx=} Failed\")\nif __name__ == '__main__':"
        },
        {
            "comment": "The code is calling a test_policy function with the task name \"sim_transfer_cube_scripted\". This suggests it's testing a simulation script for transferring a cube.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/scripted_policy.py\":191-192",
            "content": "    test_task_name = 'sim_transfer_cube_scripted'\n    test_policy(test_task_name)"
        }
    ]
}