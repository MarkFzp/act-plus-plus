{
    "summary": "The code uses DynamixelSDK for motor communication, offering a class for control and incorporating functions for cleanup, conversion, and initialization. It manages motion control through command-line arguments and handles data from Dynamixel motors in an infinite loop.",
    "details": [
        {
            "comment": "This code is for communicating with Dynamixel motors using the DynamixelSDK. It defines protocol version, addresses for various motor data, byte lengths, and scale factors for position, velocity, and current. The dynamixel_cleanup_handler function ensures Dynamixels are disconnected properly before exiting.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":0-37",
            "content": "\"\"\"Communication using the DynamixelSDK.\"\"\"\n##This is based off of the dynamixel SDK\nimport atexit\nimport logging\nimport time\nfrom typing import Optional, Sequence, Union, Tuple\nimport numpy as np\nPROTOCOL_VERSION = 2.0\n# The following addresses assume XH motors.\nADDR_TORQUE_ENABLE = 64\nADDR_GOAL_POSITION = 116\nADDR_PRESENT_POSITION = 132\nADDR_PRESENT_VELOCITY = 128\nADDR_PRESENT_CURRENT = 126\nADDR_PRESENT_POS_VEL_CUR = 126\n# Data Byte Length\nLEN_PRESENT_POSITION = 4\nLEN_PRESENT_VELOCITY = 4\nLEN_PRESENT_CURRENT = 2\nLEN_PRESENT_POS_VEL_CUR = 10\nLEN_GOAL_POSITION = 4\nDEFAULT_POS_SCALE = 2.0 * np.pi / 4096  # 0.088 degrees\n# See http://emanual.robotis.com/docs/en/dxl/x/xh430-v210/#goal-velocity\nDEFAULT_VEL_SCALE = 0.229 * 2.0 * np.pi / 60.0  # 0.229 rpm\nDEFAULT_CUR_SCALE = 1.34\ndef dynamixel_cleanup_handler():\n    \"\"\"Cleanup function to ensure Dynamixels are disconnected properly.\"\"\"\n    open_clients = list(DynamixelClient.OPEN_CLIENTS)\n    for open_client in open_clients:\n        if open_client.port_handler.is_using:\n            logging.warning('Forcing client to close.')"
        },
        {
            "comment": "The code defines a class `DynamixelClient` for communicating with Dynamixel motors, supporting Protocol 2. It also contains functions `signed_to_unsigned` and `unsigned_to_signed` for converting signed to unsigned values and vice versa. The client can be initialized with motor IDs, port, baudrate, lazy connect option, and optional position scale.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":38-73",
            "content": "        open_client.port_handler.is_using = False\n        open_client.disconnect()\ndef signed_to_unsigned(value: int, size: int) -> int:\n    \"\"\"Converts the given value to its unsigned representation.\"\"\"\n    if value < 0:\n        bit_size = 8 * size\n        max_value = (1 << bit_size) - 1\n        value = max_value + value\n    return value\ndef unsigned_to_signed(value: int, size: int) -> int:\n    \"\"\"Converts the given value from its unsigned representation.\"\"\"\n    bit_size = 8 * size\n    if (value & (1 << (bit_size - 1))) != 0:\n        value = -((1 << bit_size) - value)\n    return value\nclass DynamixelClient:\n    \"\"\"Client for communicating with Dynamixel motors.\n    NOTE: This only supports Protocol 2.\n    \"\"\"\n    # The currently open clients.\n    OPEN_CLIENTS = set()\n    def __init__(self,\n                 motor_ids: Sequence[int],\n                 port: str = '/dev/ttyUSB0',\n                 baudrate: int = 1000000,\n                 lazy_connect: bool = False,\n                 pos_scale: Optional[float] = None,"
        },
        {
            "comment": "This code snippet is the constructor of a class, initializing a new Dynamixel client. It takes motor IDs, device port, baudrate, and optional scaling factors for positions, velocities, and currents as arguments. If not provided, it uses default scales. Lazy connectivity is also available if a method requires a connection when not already connected.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":74-92",
            "content": "                 vel_scale: Optional[float] = None,\n                 cur_scale: Optional[float] = None):\n        \"\"\"Initializes a new client.\n        Args:\n            motor_ids: All motor IDs being used by the client.\n            port: The Dynamixel device to talk to. e.g.\n                - Linux: /dev/ttyUSB0\n                - Mac: /dev/tty.usbserial-*\n                - Windows: COM1\n            baudrate: The Dynamixel baudrate to communicate with.\n            lazy_connect: If True, automatically connects when calling a method\n                that requires a connection, if not already connected.\n            pos_scale: The scaling factor for the positions. This is\n                motor-dependent. If not provided, uses the default scale.\n            vel_scale: The scaling factor for the velocities. This is\n                motor-dependent. If not provided uses the default scale.\n            cur_scale: The scaling factor for the currents. This is\n                motor-dependent. If not provided uses the default scale."
        },
        {
            "comment": "This code imports the dynamixel_sdk library and initializes variables for port, baudrate, lazy connect, and protocol version. It also creates handlers for the port and packet communication and instantiates two reader classes for position, velocity, and current data. These readers can be used to access information from Dynamixel motors.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":93-117",
            "content": "        \"\"\"\n        import dynamixel_sdk\n        self.dxl = dynamixel_sdk\n        self.motor_ids = list(motor_ids)\n        self.port_name = port\n        self.baudrate = baudrate\n        self.lazy_connect = lazy_connect\n        self.port_handler = self.dxl.PortHandler(port)\n        self.packet_handler = self.dxl.PacketHandler(PROTOCOL_VERSION)\n        self._pos_vel_cur_reader = DynamixelPosVelCurReader(\n            self,\n            self.motor_ids,\n            pos_scale=pos_scale if pos_scale is not None else DEFAULT_POS_SCALE,\n            vel_scale=vel_scale if vel_scale is not None else DEFAULT_VEL_SCALE,\n            cur_scale=cur_scale if cur_scale is not None else DEFAULT_CUR_SCALE,\n        )\n        self._pos_reader = DynamixelPosReader(\n            self,\n            self.motor_ids,\n            pos_scale=pos_scale if pos_scale is not None else DEFAULT_POS_SCALE,\n            vel_scale=vel_scale if vel_scale is not None else DEFAULT_VEL_SCALE,\n            cur_scale=cur_scale if cur_scale is not None else DEFAULT_CUR_SCALE,"
        },
        {
            "comment": "The code initializes reader and writer objects for the Dynamixel motors, handles open clients, and provides a connect method. The `_vel_reader` and `_cur_reader` objects are created with optional scales for position (pos_scale), velocity (vel_scale), and current (cur_scale). These scales allow custom adjustment to the motor data readings. The `self._sync_writers` dictionary is initialized, likely used for synchronous writer operations. The code also includes an `is_connected` property that returns the status of the connection to the Dynamixel motors and a `connect` method which should be called after all DynamixelClients on the same process are created.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":118-145",
            "content": "        )\n        self._vel_reader = DynamixelVelReader(\n            self,\n            self.motor_ids,\n            pos_scale=pos_scale if pos_scale is not None else DEFAULT_POS_SCALE,\n            vel_scale=vel_scale if vel_scale is not None else DEFAULT_VEL_SCALE,\n            cur_scale=cur_scale if cur_scale is not None else DEFAULT_CUR_SCALE,\n        )\n        self._cur_reader = DynamixelCurReader(\n            self,\n            self.motor_ids,\n            pos_scale=pos_scale if pos_scale is not None else DEFAULT_POS_SCALE,\n            vel_scale=vel_scale if vel_scale is not None else DEFAULT_VEL_SCALE,\n            cur_scale=cur_scale if cur_scale is not None else DEFAULT_CUR_SCALE,\n        )\n        self._sync_writers = {}\n        self.OPEN_CLIENTS.add(self)\n    @property\n    def is_connected(self) -> bool:\n        return self.port_handler.is_open\n    def connect(self):\n        \"\"\"Connects to the Dynamixel motors.\n        NOTE: This should be called after all DynamixelClients on the same\n            process are created."
        },
        {
            "comment": "This code checks if the client is already connected and then attempts to open the port. If successful, it logs a message indicating the port has been opened. It also sets the baud rate and logs a success message if that's successful too. The code then enables all motors with True values for settings before enabling. Lastly, there is a function disconnect() which checks if the client is connected, and if so, it disconnects from the Dynamixel device.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":146-170",
            "content": "        \"\"\"\n        assert not self.is_connected, 'Client is already connected.'\n        if self.port_handler.openPort():\n            logging.info('Succeeded to open port: %s', self.port_name)\n        else:\n            raise OSError(\n                ('Failed to open port at {} (Check that the device is powered '\n                 'on and connected to your computer).').format(self.port_name))\n        if self.port_handler.setBaudRate(self.baudrate):\n            logging.info('Succeeded to set baudrate to %d', self.baudrate)\n        else:\n            raise OSError(\n                ('Failed to set the baudrate to {} (Ensure that the device was '\n                 'configured for this baudrate).').format(self.baudrate))\n        # Start with all motors enabled.  NO, I want to set settings before enabled\n        #self.set_torque_enabled(self.motor_ids, True)\n    def disconnect(self):\n        \"\"\"Disconnects from the Dynamixel device.\"\"\"\n        if not self.is_connected:\n            return\n        if self.port_handler.is_using:"
        },
        {
            "comment": "The code is disconnecting the port handler and ensuring motors are disabled. It removes the client from OPEN_CLIENTS, sets motor torque enabled or disabled, retries if necessary, and waits between retries for a specific duration.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":171-195",
            "content": "            logging.error('Port handler in use; cannot disconnect.')\n            return\n        # Ensure motors are disabled at the end.\n        self.set_torque_enabled(self.motor_ids, False, retries=0)\n        self.port_handler.closePort()\n        if self in self.OPEN_CLIENTS:\n            self.OPEN_CLIENTS.remove(self)\n    def set_torque_enabled(self,\n                           motor_ids: Sequence[int],\n                           enabled: bool,\n                           retries: int = -1,\n                           retry_interval: float = 0.25):\n        \"\"\"Sets whether torque is enabled for the motors.\n        Args:\n            motor_ids: The motor IDs to configure.\n            enabled: Whether to engage or disengage the motors.\n            retries: The number of times to retry. If this is <0, will retry\n                forever.\n            retry_interval: The number of seconds to wait between retries.\n        \"\"\"\n        remaining_ids = list(motor_ids)\n        while remaining_ids:\n            remaining_ids = self.write_byte("
        },
        {
            "comment": "The code defines a function to set the torque of Dynamixel motors. It iterates over each ID and enables/disables the torque for them. If there are remaining unsuccessful IDs, it logs an error message. The code also includes methods to read positions, velocities, and currents from the motors. Each method uses a reader object to retrieve the data.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":196-220",
            "content": "                remaining_ids,\n                int(enabled),\n                ADDR_TORQUE_ENABLE,\n            )\n            if remaining_ids:\n                logging.error('Could not set torque %s for IDs: %s',\n                              'enabled' if enabled else 'disabled',\n                              str(remaining_ids))\n            if retries == 0:\n                break\n            time.sleep(retry_interval)\n            retries -= 1\n    def read_pos_vel_cur(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:\n        \"\"\"Returns the current positions and velocities.\"\"\"\n        return self._pos_vel_cur_reader.read()\n    def read_pos(self) -> np.ndarray:\n        \"\"\"Returns the current positions and velocities.\"\"\"\n        return self._pos_reader.read()\n    def read_vel(self) -> np.ndarray:\n        \"\"\"Returns the current positions and velocities.\"\"\"\n        return self._vel_reader.read()\n    def read_cur(self) -> np.ndarray:\n        \"\"\"Returns the current positions and velocities.\"\"\"\n        return self._cur_reader.read()"
        },
        {
            "comment": "This code defines two functions, \"write_desired_pos\" and \"write_byte\". The first function writes the given desired positions to the specified motor IDs. It takes in a list of motor IDs and an array of joint angles, converts the angles to Dynamixel position space, then uses sync_write to write the positions to the motors' goal position address. The second function writes a value to the control table at a given address for specified motor IDs. It returns a list of unsuccessful IDs if any occur during writing.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":222-253",
            "content": "    def write_desired_pos(self, motor_ids: Sequence[int],\n                          positions: np.ndarray):\n        \"\"\"Writes the given desired positions.\n        Args:\n            motor_ids: The motor IDs to write to.\n            positions: The joint angles in radians to write.\n        \"\"\"\n        assert len(motor_ids) == len(positions)\n        # Convert to Dynamixel position space.\n        positions = positions / self._pos_vel_cur_reader.pos_scale\n        self.sync_write(motor_ids, positions, ADDR_GOAL_POSITION,\n                        LEN_GOAL_POSITION)\n    def write_byte(\n            self,\n            motor_ids: Sequence[int],\n            value: int,\n            address: int,\n    ) -> Sequence[int]:\n        \"\"\"Writes a value to the motors.\n        Args:\n            motor_ids: The motor IDs to write to.\n            value: The value to write to the control table.\n            address: The control table address to write to.\n        Returns:\n            A list of IDs that were unsuccessful.\n        \"\"\"\n        self.check_connected()"
        },
        {
            "comment": "This code defines a function `sync_write` that takes motor IDs, values, address, and size as input to write the same value at the specified address for multiple motors. It first checks if the connection is established and then creates a key based on the address and size. If this key is not present in the internal dictionary `self._sync_writers`, it initializes a GroupSyncWrite operation with the given parameters. This function also returns an empty list of motor IDs that had errors during the write operation, which are stored in the variable `errored_ids` by checking if each write operation was successful or not.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":254-278",
            "content": "        errored_ids = []\n        for motor_id in motor_ids:\n            comm_result, dxl_error = self.packet_handler.write1ByteTxRx(\n                self.port_handler, motor_id, address, value)\n            success = self.handle_packet_result(\n                comm_result, dxl_error, motor_id, context='write_byte')\n            if not success:\n                errored_ids.append(motor_id)\n        return errored_ids\n    def sync_write(self, motor_ids: Sequence[int],\n                   values: Sequence[Union[int, float]], address: int,\n                   size: int):\n        \"\"\"Writes values to a group of motors.\n        Args:\n            motor_ids: The motor IDs to write to.\n            values: The values to write.\n            address: The control table address to write to.\n            size: The size of the control table value being written to.\n        \"\"\"\n        self.check_connected()\n        key = (address, size)\n        if key not in self._sync_writers:\n            self._sync_writers[key] = self.dxl.GroupSyncWrite("
        },
        {
            "comment": "The code snippet handles synchronous writes to multiple motors. It iterates over motor IDs and desired positions, converts them to the required format, adds them to the packet writer, logs any failures, sends the packet, clears the packet writer, and checks if the robot is connected.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":279-306",
            "content": "                self.port_handler, self.packet_handler, address, size)\n        sync_writer = self._sync_writers[key]\n        errored_ids = []\n        for motor_id, desired_pos in zip(motor_ids, values):\n            value = signed_to_unsigned(int(desired_pos), size=size)\n            value = value.to_bytes(size, byteorder='little')\n            success = sync_writer.addParam(motor_id, value)\n            if not success:\n                errored_ids.append(motor_id)\n        if errored_ids:\n            logging.error('Sync write failed for: %s', str(errored_ids))\n        comm_result = sync_writer.txPacket()\n        self.handle_packet_result(comm_result, context='sync_write')\n        sync_writer.clearParam()\n    def check_connected(self):\n        \"\"\"Ensures the robot is connected.\"\"\"\n        if self.lazy_connect and not self.is_connected:\n            self.connect()\n        if not self.is_connected:\n            raise OSError('Must call connect() first.')\n    def handle_packet_result(self,\n                             comm_result: int,"
        },
        {
            "comment": "This function handles communication results and checks for errors. It formats the error message with motor ID and context if provided, then logs the error and returns False. The convert_to_unsigned function converts a given value to its unsigned representation.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":307-328",
            "content": "                             dxl_error: Optional[int] = None,\n                             dxl_id: Optional[int] = None,\n                             context: Optional[str] = None):\n        \"\"\"Handles the result from a communication request.\"\"\"\n        error_message = None\n        if comm_result != self.dxl.COMM_SUCCESS:\n            error_message = self.packet_handler.getTxRxResult(comm_result)\n        elif dxl_error is not None:\n            error_message = self.packet_handler.getRxPacketError(dxl_error)\n        if error_message:\n            if dxl_id is not None:\n                error_message = '[Motor ID: {}] {}'.format(\n                    dxl_id, error_message)\n            if context is not None:\n                error_message = '> {}: {}'.format(context, error_message)\n            logging.error(error_message)\n            return False\n        return True\n    def convert_to_unsigned(self, value: int, size: int) -> int:\n        \"\"\"Converts the given value to its unsigned representation.\"\"\"\n        if value < 0:"
        },
        {
            "comment": "This code defines a DynamixelReader class for reading data from Dynamixel motors using GroupBulkRead from the DynamixelSDK. It also provides context management functionality with __enter__ and __exit__ methods, and automatically disconnects on destruction with __del__.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":329-364",
            "content": "            max_value = (1 << (8 * size)) - 1\n            value = max_value + value\n        return value\n    def __enter__(self):\n        \"\"\"Enables use as a context manager.\"\"\"\n        if not self.is_connected:\n            self.connect()\n        return self\n    def __exit__(self, *args):\n        \"\"\"Enables use as a context manager.\"\"\"\n        self.disconnect()\n    def __del__(self):\n        \"\"\"Automatically disconnect on destruction.\"\"\"\n        self.disconnect()\nclass DynamixelReader:\n    \"\"\"Reads data from Dynamixel motors.\n    This wraps a GroupBulkRead from the DynamixelSDK.\n    \"\"\"\n    def __init__(self, client: DynamixelClient, motor_ids: Sequence[int],\n                 address: int, size: int):\n        \"\"\"Initializes a new reader.\"\"\"\n        self.client = client\n        self.motor_ids = motor_ids\n        self.address = address\n        self.size = size\n        self._initialize_data()\n        self.operation = self.client.dxl.GroupBulkRead(client.port_handler,\n                                                       client.packet_handler)"
        },
        {
            "comment": "This code adds parameters to a bulk read operation for each motor ID, reads data from motors with retries in case of errors or disconnections, and returns previous data if the read fails.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":366-391",
            "content": "        for motor_id in motor_ids:\n            success = self.operation.addParam(motor_id, address, size)\n            if not success:\n                raise OSError(\n                    '[Motor ID: {}] Could not add parameter to bulk read.'\n                    .format(motor_id))\n    def read(self, retries: int = 1):\n        \"\"\"Reads data from the motors.\"\"\"\n        self.client.check_connected()\n        success = False\n        while not success and retries >= 0:\n            comm_result = self.operation.txRxPacket()\n            success = self.client.handle_packet_result(\n                comm_result, context='read')\n            retries -= 1\n        # If we failed, send a copy of the previous data.\n        if not success:\n            return self._get_data()\n        errored_ids = []\n        for i, motor_id in enumerate(self.motor_ids):\n            # Check if the data is available.\n            available = self.operation.isAvailable(motor_id, self.address,\n                                                   self.size)"
        },
        {
            "comment": "This code is part of a Dynamixel client that communicates with a robot's servo motors to read position and velocity data. It initializes the cached data, updates the data for specific motor IDs, returns a copy of the data, and handles cases where data is unavailable.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":392-424",
            "content": "            if not available:\n                errored_ids.append(motor_id)\n                continue\n            self._update_data(i, motor_id)\n        if errored_ids:\n            logging.error('Bulk read data is unavailable for: %s',\n                          str(errored_ids))\n        return self._get_data()\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        self._data[index] = self.operation.getData(motor_id, self.address,\n                                                   self.size)\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return self._data.copy()\nclass DynamixelPosVelCurReader(DynamixelReader):\n    \"\"\"Reads positions and velocities.\"\"\"\n    def __init__(self,\n                 client: DynamixelClient,\n                 motor_ids: Sequence[int],\n                 pos_scale: float = 1.0,"
        },
        {
            "comment": "This code defines a class for reading Dynamixel servo data. It takes in a client, motor IDs, and scales for position, velocity, and current. It initializes cached data arrays with zeros for each motor. The _update_data function reads and stores the current, velocity, and position data from the specified address for the given motor ID.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":425-449",
            "content": "                 vel_scale: float = 1.0,\n                 cur_scale: float = 1.0):\n        super().__init__(\n            client,\n            motor_ids,\n            address=ADDR_PRESENT_POS_VEL_CUR,\n            size=LEN_PRESENT_POS_VEL_CUR,\n        )\n        self.pos_scale = pos_scale\n        self.vel_scale = vel_scale\n        self.cur_scale = cur_scale\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._pos_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n        self._vel_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n        self._cur_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        cur = self.operation.getData(motor_id, ADDR_PRESENT_CURRENT,\n                                     LEN_PRESENT_CURRENT)\n        vel = self.operation.getData(motor_id, ADDR_PRESENT_VELOCITY,\n                                     LEN_PRESENT_VELOCITY)\n        pos = self.operation.getData(motor_id, ADDR_PRESENT_POSITION,"
        },
        {
            "comment": "The code defines a class `DynamixelPosReader` that inherits from `DynamixelReader` and reads positions and velocities of motors. It takes a client, motor IDs, and scaling factors for position, velocity, and current as parameters. The `__init__` method initializes the superclass with the address and size for reading present position, velocity, and current data. The `_get_data` method returns a copy of the stored position, velocity, and current data.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":450-478",
            "content": "                                     LEN_PRESENT_POSITION)\n        cur = unsigned_to_signed(cur, size=2)\n        vel = unsigned_to_signed(vel, size=4)\n        pos = unsigned_to_signed(pos, size=4)\n        self._pos_data[index] = float(pos) * self.pos_scale\n        self._vel_data[index] = float(vel) * self.vel_scale\n        self._cur_data[index] = float(cur) * self.cur_scale\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return (self._pos_data.copy(), self._vel_data.copy(),\n                self._cur_data.copy())\nclass DynamixelPosReader(DynamixelReader):\n    \"\"\"Reads positions and velocities.\"\"\"\n    def __init__(self,\n                 client: DynamixelClient,\n                 motor_ids: Sequence[int],\n                 pos_scale: float = 1.0,\n                 vel_scale: float = 1.0,\n                 cur_scale: float = 1.0):\n        super().__init__(\n            client,\n            motor_ids,\n            address=ADDR_PRESENT_POS_VEL_CUR,\n            size=LEN_PRESENT_POS_VEL_CUR,\n        )"
        },
        {
            "comment": "The code defines a class `DynamixelReader` that reads position and velocity data from Dynamixel motors. It initializes cached data, updates the data for a given motor ID, and returns a copy of the data. The `DynamixelVelReader` subclass extends this functionality to read positions, velocities, and currents.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":479-508",
            "content": "        self.pos_scale = pos_scale\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._pos_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        pos = self.operation.getData(motor_id, ADDR_PRESENT_POSITION,\n                                     LEN_PRESENT_POSITION)\n        pos = unsigned_to_signed(pos, size=4)\n        self._pos_data[index] = float(pos) * self.pos_scale\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return self._pos_data.copy()\nclass DynamixelVelReader(DynamixelReader):\n    \"\"\"Reads positions and velocities.\"\"\"\n    def __init__(self,\n                 client: DynamixelClient,\n                 motor_ids: Sequence[int],\n                 pos_scale: float = 1.0,\n                 vel_scale: float = 1.0,\n                 cur_scale: float = 1.0):\n        super().__init__(\n            client,\n            motor_ids,\n            address=ADDR_PRESENT_POS_VEL_CUR,"
        },
        {
            "comment": "This code defines a class DynamixelCurReader that inherits from DynamixelReader and reads positions and velocities from dynamixel motors. The constructor takes in a client, motor IDs, optional position scale, and optional velocity scale. It initializes cached data and sets the position and velocity scales. The _initialize_data method initializes the velocity data with zeros. The _update_data method updates the data index for the given motor ID by getting the velocity from the DynamixelClient, converting it to a signed integer, scaling it by the velocity scale, and storing it in the velocity data. The _get_data method returns a copy of the velocity data.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":509-537",
            "content": "            size=LEN_PRESENT_POS_VEL_CUR,\n        )\n        self.pos_scale = pos_scale\n        self.vel_scale = vel_scale\n        self.cur_scale = cur_scale\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._vel_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        vel = self.operation.getData(motor_id, ADDR_PRESENT_VELOCITY,\n                                     LEN_PRESENT_VELOCITY)\n        vel = unsigned_to_signed(vel, size=4)\n        self._vel_data[index] = float(vel) * self.vel_scale\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return self._vel_data.copy()\nclass DynamixelCurReader(DynamixelReader):\n    \"\"\"Reads positions and velocities.\"\"\"\n    def __init__(self,\n                 client: DynamixelClient,\n                 motor_ids: Sequence[int],\n                 pos_scale: float = 1.0,\n                 vel_scale: float = 1.0,"
        },
        {
            "comment": "The code defines a class for reading the present current values from Dynamixel motors. It initializes data and updates data index for the given motor ID. The function returns a copy of the data. Global cleanup function is registered for atexit module to handle clean-up operations upon program termination.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":538-570",
            "content": "                 cur_scale: float = 1.0):\n        super().__init__(\n            client,\n            motor_ids,\n            address=ADDR_PRESENT_POS_VEL_CUR,\n            size=LEN_PRESENT_POS_VEL_CUR,\n        )\n        self.cur_scale = cur_scale\n    def _initialize_data(self):\n        \"\"\"Initializes the cached data.\"\"\"\n        self._cur_data = np.zeros(len(self.motor_ids), dtype=np.float32)\n    def _update_data(self, index: int, motor_id: int):\n        \"\"\"Updates the data index for the given motor ID.\"\"\"\n        cur = self.operation.getData(motor_id, ADDR_PRESENT_CURRENT,\n                                     LEN_PRESENT_CURRENT)\n        cur = unsigned_to_signed(cur, size=2)\n        self._cur_data[index] = float(cur) * self.cur_scale\n    def _get_data(self):\n        \"\"\"Returns a copy of the data.\"\"\"\n        return self._cur_data.copy()\n# Register global cleanup function.\natexit.register(dynamixel_cleanup_handler)\nif __name__ == '__main__':\n    import argparse\n    import itertools\n    parser = argparse.ArgumentParser()"
        },
        {
            "comment": "The code defines command-line arguments for motor IDs, device, and baudrate. It then parses these arguments into a list of motors, and creates waypoints for motion control using numpy arrays. The DynamixelClient class is instantiated with the parsed arguments, and in an infinite loop, writes waypoint positions to motors and reads current position, velocity, and current values from the device at regular intervals.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":571-597",
            "content": "    parser.add_argument(\n        '-m',\n        '--motors',\n        required=True,\n        help='Comma-separated list of motor IDs.')\n    parser.add_argument(\n        '-d',\n        '--device',\n        default='/dev/ttyUSB0',\n        help='The Dynamixel device to connect to.')\n    parser.add_argument(\n        '-b', '--baud', default=1000000, help='The baudrate to connect with.')\n    parsed_args = parser.parse_args()\n    motors = [int(motor) for motor in parsed_args.motors.split(',')]\n    way_points = [np.zeros(len(motors)), np.full(len(motors), np.pi)]\n    with DynamixelClient(motors, parsed_args.device,\n                         parsed_args.baud) as dxl_client:\n        for step in itertools.count():\n            if step > 0 and step % 50 == 0:\n                way_point = way_points[(step // 100) % len(way_points)]\n                print('Writing: {}'.format(way_point.tolist()))\n                dxl_client.write_desired_pos(motors, way_point)\n            read_start = time.time()\n            pos_now, vel_now, cur_now = dxl_client.read_pos_vel_cur()"
        },
        {
            "comment": "This code block prints the frequency, positions, velocities, and currents of the dynamixel servos every 5 steps in the loop.",
            "location": "\"/media/root/Prima/works/act-plus-plus/docs/src/dynamixel_client.py\":598-603",
            "content": "            if step % 5 == 0:\n                print('[{}] Frequency: {:.2f} Hz'.format(\n                    step, 1.0 / (time.time() - read_start)))\n                print('> Pos: {}'.format(pos_now.tolist()))\n                print('> Vel: {}'.format(vel_now.tolist()))\n                print('> Cur: {}'.format(cur_now.tolist()))"
        }
    ]
}